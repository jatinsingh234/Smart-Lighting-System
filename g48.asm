#make_bin#

; BIN is plain binary format similar to .com format, but not limited to 1 segment;
; All values between # are directives, these values are saved into a separate .binf file.
; Before loading .bin file emulator reads .binf file with the same file name.

; All directives are optional, if you don't need them, delete them.

; set loading address, .bin file will be loaded to this address:
#LOAD_SEGMENT=0500h#
#LOAD_OFFSET=0000h#

; set entry point:
#CS=0500h#	; same as loading segment
#IP=0000h#	; same as loading offset

; set segment registers
#DS=0500h#	; same as loading segment
#ES=0500h#	; same as loading segment

; set stack
#SS=0500h#	; same as loading segment
#SP=FFFEh#	; set to top of loading segment

; set general registers (optional)
#AX=0000h#
#BX=0000h#
#CX=0000h#
#DX=0000h#
#SI=0000h#
#DI=0000h#
#BP=0000h#

VARS:

CNT DW 00H;total count of people inside the room
ROWCOUNT DB 00H,00H,00H,00H,00H,00H; stores count of individual rows
GATE DB 0
STRLEN DB 0
DAT1 DB 5 DUP(0)
DAT2 DB 4 DUP(0)

;8255 ports 
PORTA EQU 00H
PORTB EQU 02H
PORTC EQU 04H
creg EQU 06H

JMP     START
DB     1001 DUP(0)

START:
;INITIALIZE REGISTERS TO START OF RAM
MOV       AX,02000H
MOV       DS,AX
MOV       ES,AX
MOV       SS,AX
MOV       SP,02FFEH

;INTIALISE PORTA AND PORT AS INPUT & PORTC AS OUTPUT FOR 8255
MOV     AL,92H
OUT     creg,AL

;ENSURING ALL LIGHTS ARE TURNED OFF AT THE BEGINNING
MOV AL,00H
OUT 04H,AL

STARTUP:
CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;if sensor1 triggered first, entry
;if sensor2 triggered first, exit

;ENTRY CHECK
X1: 
	IN AL,02H
	AND AL,80H ;CHECKING IF GATE SENSOR 1 HIGH
	CMP AL,80H
	JNZ X2
Y1: 
	IN AL,02H
	AND AL,40H ;CHECKING IF GATE SENSOR 2 HIGH
	CMP AL,40H
	JNZ Y1
	ADD [CNT],1 ;INCREASE TOTAL COUNT OF PEOPLE BY 1
	MOV GATE,1

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;EXIT CHECK
X2:
	IN AL,02H
	AND AL,40H ;CHECKING IF GATE SENSOR 2 HIGH
	CMP AL,40H
	JNZ X5
Y2: 
	IN AL,02H
	AND AL,80H ;CHECKING IF GATE SENSOR 1 HIGH
	CMP AL,80H
	JNZ Y2
	SUB [CNT],1 ;DECREASE TOTAL COUNT OF PEOPLE BY 1
	MOV GATE,0

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC
CALL DELAY


;CHECK IF ENTRY IN ROW1
X5: 
	IN AL,02H  ;port input
	AND AL,08H   ;check if first row sensor 1 triggered
	CMP AL,08H   ;if triggered, check if sensor 2 triggered to confirm entry
	JNZ X6       ;if not triggered, go to exit check
Y5: 
	IN AL,02H
	AND AL,04H
	CMP AL,04H
	JNZ Y5       ;if sensor 2 not triggered, wait till trigger
	ADD [ROWCOUNT],1 ;increase the count in row 1 by 1
	CMP [ROWCOUNT], 10
	JLE Z1
	SUB [ROWCOUNT], 1
	Z1: JMP X 

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF EXIT FROM ROW1
X6: 
	IN AL,02H
	AND AL,04H
	CMP AL,04H;same as entry but sensor order reveresed
	JNZ X7;if not triggered check for row2 entry
Y6: 
	IN AL,02H
	AND AL,08H
	CMP AL,08H
	JNZ Y6
	SUB [ROWCOUNT],1
	JMP X  

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF ENTRY IN ROW2
X7: 
	IN AL,02H
	AND AL,02H
	CMP AL,02H
	JNZ X8
Y7: 
	IN AL,02H
	AND AL,01H
	CMP AL,01H
	JNZ Y7
	ADD [ROWCOUNT+1],1
	CMP [ROWCOUNT+1], 10
	JLE Z1
	SUB [ROWCOUNT+1], 1
	JMP X 

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF EXIT FROM ROW2
X8: 
	IN AL,02H
	AND AL,01H
	CMP AL,01H
	JNZ X9
Y8: 
	IN AL,02H
	AND AL,02H
	CMP AL,02H
	JNZ Y8
	SUB [ROWCOUNT+1],1
	JMP X

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF ENTRY IN ROW3
X9: 
	IN AL,00H
	AND AL,80H
	CMP AL,80H
	JNZ X10
Y9: 
	IN AL,00H
	AND AL,40H
	CMP AL,40H
	JNZ Y9
	ADD [ROWCOUNT+2],1
	CMP [ROWCOUNT+2], 10
	JLE Z1
	SUB [ROWCOUNT+2], 1
	JMP X

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF EXIT FROM ROW3
X10: 
	IN AL,00H
	AND AL,40H
	CMP AL,40H
	JNZ X11
Y10: 
	IN AL,00H
	AND AL,80H
	CMP AL,80H
	JNZ Y10
	SUB [ROWCOUNT+2],1
	JMP X

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF ENTRY IN ROW4
X11: 
	IN AL,00H
	AND AL,20H
	CMP AL,20H
	JNZ X12
Y11: 
	IN AL,00H
	AND AL,10H
	CMP AL,10H
	JNZ Y11
	ADD [ROWCOUNT+3],1
	CMP [ROWCOUNT+3], 10
	JLE Z1
	SUB [ROWCOUNT+3], 1
	JMP X

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF EXIT FROM ROW4
X12: 
	IN AL,00H
	AND AL,10H
	CMP AL,10H
	JNZ X13
Y12: 
	IN AL,00H
	AND AL,20H
	CMP AL,20H
	JNZ Y12
	SUB [ROWCOUNT+3],1
	JMP X

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF ENTRY IN ROW5
X13:
	IN AL,00H
	AND AL,08H
	CMP AL,08H
	JNZ X14
Y13: 
	IN AL,00H
	AND AL,04H
	CMP AL,04H
	JNZ Y13
	ADD [ROWCOUNT+4],1
	CMP [ROWCOUNT+4], 10
	JLE Z1
	SUB [ROWCOUNT+4], 1
	JMP X

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF EXIT FROM ROW5
X14: 
	IN AL,00H
	AND AL,04H
	CMP AL,04H
	JNZ X15
Y14: 
	IN AL,00H
	AND AL,08H
	CMP AL,08H
	JNZ Y14
	SUB [ROWCOUNT+4],1
	JMP X

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF ENTRY IN ROW6
X15: 
	IN AL,00H
	AND AL,02H
	CMP AL,02H
	JNZ X16
Y15: 
	IN AL,00H
	AND AL,01H
	CMP AL,01H
	JNZ Y15
	ADD [ROWCOUNT+5],1
	CMP [ROWCOUNT+5], 10
	JLE Z1
	SUB [ROWCOUNT+5], 1
	JMP X

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;CHECK IF EXIT FROM ROW6
X16: 
	IN AL,00H
	AND AL,01H
	CMP AL,01H
	JNZ X
Y16: 
	IN AL,00H
	AND AL,02H
	CMP AL,02H
	JNZ Y16
	SUB [ROWCOUNT+5],1

CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC

;TURN LIGHTS OF THE ROW ON/OFF
X:  
	MOV AL,00H
	MOV BL,01H
	MOV CX,06H
	LEA SI,ROWCOUNT
Y:  
	MOV DL,[SI]
	CMP DL,00H
	JNZ Z
	JMP W
Z:  
	OR AL,BL ;IF COUNT OF THE ROW >0, MAKE THE BIT OF THAT ROW = 1, ENSURING LIGHTS REMAIN TURNED ON

W:  
	ROL BL,1
	ADD SI,1
	DEC CX
	CMP CX,00H
	JNZ Y
	OUT 04H,AL ;GIVE THE OUTPUT
	
CALL DELAY_OF_1SEC
CALL DELAY_OF_1SEC
;CALL DELAY_OF_1SEC
;CALL DELAY_OF_1SEC
;CALL DELAY_OF_1SEC
;CALL DELAY_OF_1SEC
;CALL DELAY_OF_1SEC
;CALL DELAY_OF_1SEC
;CALL DELAY_OF_1SEC

DISP:
	JMP X1


DELAY_OF_1SEC PROC
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
		CALL DELAY
RET
DELAY_OF_1SEC ENDP

DELAY PROC
		MOV CX, 1325 ;1325*15.085 USEC = 20 MSEC
		W1:
			NOP
			NOP
			NOP
			NOP
			NOP
			LOOP W1
		RET
DELAY ENDP